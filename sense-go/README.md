# sense-go

sense-go is a Balena container written in Go that provides the bulk of the functionality of
the edge-devices, including sensing, control of AC devices (heater ...), and control of nutrient
dispensers.

sense-go supports the following sensors:

- pH
- CO2/VOC
- water level
- water temperature

as well as the dispensers and all the controllable devices.

The configuration of the device, what modules it supports and how it connects to them, is
contained in [the database](https://github.com/bubblesnet/documentation/Database.md)

## Naming data

Within the code throughout the rest of the system, the data names are almost always
the exact same in code as they are in the database - long, descriptive snake-case and Pascal-case with 
leading lower case. This is great for javascript and Python, but doesn't work in Go. 
Instead, Go types have the concept of "JSON representation". Usually a Go name is the
Pascal-case leading upper-case version of the original name.

I tried to consolidate all the types and constants with files in the 
[globals directory](globals), particularly [config](globals/config.go), 
[types](globals/types.go), [constants](globals/constants.go)
and [globals](globals/globals.go). There is some moosh between types and globals, but
constants is pretty clean.

The goal of constants in particular is to have the same constant names in the Go code
as are used in Python and NodeJS since using all-caps-snake-case for constants in all of
those languages is only a minor crime against computer science.

While the goal of naming within the globals directory is to enforce consistency,
and reduce the error-prone redundancy of hard-coded strings within and across projects I'd 
estimate that this project is about halfway there.

## Container Configuration

This container originally configured itself from three manually maintained files - 
hostname, deviceid and [config.json](testdata/config.json). Hostname and deviceid
became environment variable. Config.json remains but is regenerated by sense-go from an API
call on container startup. All containers use config.json for configuration, but only
sense-go regenerates it from API call.

## Directory Structure


| directory   | description                                                                 |
|-------------|-----------------------------------------------------------------------------|
| bubblesgrpc | Generated code copied from the store-and-forward container                  |
| build       | Output directory for compiled builds of the Go code                         |
| globals     | See above - globals, constants and types live here                          |
| magefiles   | Files to configure the mage build, most analogous to package.json from Node |
| messaging   | Messaging definitions a level above the raw GRPC in bubblesgrpc.            |
| modules     | All the sensor and GPIO code                                                |
| testdata    | Data to drive the Go tests                                                  |
| go.mod      | Go modules directory - generated                                            |

## Scripts and Mage

Mage was a very late addition to the project which originally ran on scripts. Any 
script prefixed with "build", "coverage", "test" or "deploy" is deprecated in favor
of mage targets. Our use of mage is simplistic right now.

## Dockerfile.template

[Dockerfile.template](Dockerfile.template) describes the sense-go container that 
the Balena CLI will build when we deploy.  modprobe and ENV directives are Raspberry 
Pi magic. Why we have to run ``` apt update ``` to get anything done is beyond me
but that's the way it is.

I keep a ``` CMD ["bash"] ``` command commented out at the end of every Dockerfile.template
file for debugging purposes. Uncomment that line and comment out the line above it
that runs the actual app in order to debug through the Balena console.

As written, the container runs our app "sense-go" as the final command in the startup
code and EXITS THE CONTAINER when our app exits. That's why that bash hack is often
useful. It's also why the [environment variable](https://github.com/bubblesnet/documentation/blob/master/balena/EnvironmentVariables.md)
SLEEP_ON_EXIT_FOR_DEBUGGING exists. When the container exits for any reason it will
still sleep for SLEEP_ON_EXIT_FOR_DEBUGGING seconds. This allows you to fire up
a Balena console and mess around in the container to see what's up.
